工厂设计理念
本mod为避免访问和执行庞大而复杂的弹幕数据和多样化修饰器引起显著卡顿，将mod的运作分为两个部分令其分割为多线程运作。
分别是主线程(负责管理并更新弹幕文本对象、调用触发器)和工厂线程(负责接收触发器并进行一系列操作后将生成的弹幕文本提交给主线程)。

工厂可看作一个黑箱，其输入口是触发器，输出口产出加工完毕只等着发送的弹幕文本。
输入口可存在多个，在通往输出口之间的过程称为工厂管线，就像产品制造流水线一样。
包括触发器在内，工厂由若干个多种类型的节点组成，节点之间按照类型有固定的排列顺序，相互关联形成工厂管线。
节点的类型有：
- 触发器。用于绑定到游戏中发生的特定事件，使用原理诸如订阅游戏自带的委托(Action)、使用Harmony对特定方法打补丁等。
- 过滤器。用于逻辑判断和过滤触发信号的节点，过滤器自己决定订阅哪些触发器，可判断是否丢弃本次触发，如果通过则调用本过滤器指定的抽取器。
- 抽取器。每个抽取器自带一个生成器表，抽取器用于创建一个生成器队列并从自身的表中选取若干个生成器加入其中，然后调用队列中的所有生成器。
- 生成器。用于实现最终弹幕文本的节点，使用自身的数据源与修饰器或者调用外部方法来制成成品文本。

数据包：
本mod将在包括自身在内的所有mod文件夹中搜寻flc_data.json并将内容读取出来后合并到一起。完成读取阶段以后会实例化所有节点，并使触发器锚定侦听目标。

flc_data.json格式：
{} 根标签
	{} triggers 触发器数据表
		~{} <触发器UID> 一个触发器数据
			string|int type 该触发器的类型，可以为Action(0) -或Harmony(1)- (先不支持Harmony了)
			string class_name 该触发器的订阅目标类，需填写含命名空间的类型名称
			string target 该触发器的订阅目标，目标的类型受type决定
	{} filters 过滤器数据表
		~{} <过滤器UID> 一个过滤器数据
			[] scribe_triggers 该过滤器订阅的触发器列表
				~string <触发器UID> 一个触发器
			[] commands 该过滤器的命令队列
				~string <命令内容> 一条过滤器命令
	{} selectors 抽取器数据表
		~{} <抽取器UID> 一个抽取器数据
			int rolls 该抽取器进行几次抽取
			[] pool 抽取池
				~{} 一个抽取项
					int weight 该抽取项的权重
					[] generators 该抽取器的生成器列表
						~string <生成器UID>
	{} generators 生成器数据表
		~{} <生成器UID> 一个生成器数据
			string|int type 该生成器的类型，可以为Normal(0)或External(1)
			string source 数据源，为Normal类型时代表原初文本，为External时代表要调用的方法
			{} modifiers 修饰器，仅限Normal类型可使用
				*[] repeat 重复修饰器，重复文本一定次数
					<...需参考重复修饰器参数用法...>
				*[] misspell 错别字修饰器
					<...需参考错别字修饰器参数用法...>

过滤器命令：
ret [if|else]
	立即跳出执行，如果含有if则仅当上一次if通过时跳出执行，如果含有else则仅当上一次if不通过时跳出执行
goto <line> [if|else]
	条件跳转，line指代命令序号，如果含有if则仅当上一次if通过时跳转，如果含有else则仅当上一次if不通过时跳转
slt <selector> [rdm <min> <max>]
	调用抽取器，select为抽选器UID，如果带有rdm子命令，则后续可指定调用抽选器的次数，min为随机最小次数，max为随机最大次数
if <cmd> [<...>]
	如果判断，cmd处可以为rdb、call
	if cmd rdb <chance>
		chance填写一个表示百分比的数字，范围为0-1，指代有多少概率通过
	if cmd call <method>
		method填写一个使用